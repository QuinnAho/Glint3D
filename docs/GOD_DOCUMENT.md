Glint3D is a data-oriented, modular rendering system built around a versioned JSON-Ops schema that defines scenes, materials, cameras, lights, render passes, and schedules as immutable, machine-readable specs. A deterministic job system consumes these specs and executes a render-graph (dependency-ordered passes with explicit resource edges) over a Render Hardware Interface (RHI) that cleanly abstracts current backends (OpenGL/WebGL2) and future ones (Vulkan/WebGPU). Resources (buffers, textures, BLAS/TLAS, splat clouds) are lifetime-managed via handle tables and arenas, with content-addressed caches (hash of asset+params) to guarantee reproducible outputs and instant re-use in headless batches. The asset pipeline normalizes heterogeneous inputs (CAD/mesh/point-cloud/NeRF), bakes them into engine-native packs, and records a provenance manifest for exact rebuilds. A deterministic PRNG seeds any sampling paths to make renders byte-stable across platforms. All state mutation flows through idempotent ops (no hidden globals), making runs auditable and easy to diff.

On top of the core sits an experiment/agent layer: a task module (spec + checklist + progress log) and machine-optimized telemetry (structured events with timing, counters, histograms, and image metrics) that feed closed-loop automation without touching UI code. Gaussian Splatting and NeRF are implemented as first-class pass types in the render-graph, sharing the same resource model and scheduling as raster passes; splat previews can be scheduled as early, low-cost passes to provide immediate visual feedback while geometry/texture streaming completes. The scheduler supports headless CLI and service modes (batch or queue-driven), with sandboxed, rate-limited op application for safety. Hot-reloadable shading packages (material DSL → backend shaders) and capability queries (RHI features, limits) allow the same JSON-Op to specialize per device at compile time. In short: a spec-driven render graph over a swappable RHI, with deterministic execution, content-addressed caching, and structured telemetry—engineered so humans or agents can orchestrate complex rendering workflows with reproducible, debuggable precision.