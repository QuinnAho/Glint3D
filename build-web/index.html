<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OpenGLOBJViewer (Web)</title>
    <style>
      html, body { height: 100%; margin: 0; }
      #wrap { position: relative; height: 100%; width: 100%; background: #111; }
      #glcanvas { width: 100%; height: 100%; display: block; outline: none; }
      #topbar { position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; gap: 8px; }
      #topbar button, #topbar label { font: 13px system-ui, sans-serif; }
      #file-input { display: none; }
      #drop { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; z-index: 4; background: rgba(0,0,0,0.35); color: #fff; font: 600 18px system-ui, sans-serif; border: 2px dashed #4caf50; }
      #hint { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.5); color: #ddd; padding: 6px 8px; border-radius: 4px; font: 12px system-ui, sans-serif; }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="glcanvas" class="emscripten" tabindex="1"></canvas>
      <div id="topbar">
        <label for="file-input" style="background:#2e7d32;color:#fff;padding:6px 10px;border-radius:4px;cursor:pointer;">Open model</label>
        <input id="file-input" type="file" accept=".obj,.ply,.glb,.gltf,.fbx,.dae" />
      </div>
      <div id="drop">Drop model file (.obj/.ply/.glb)</div>
      <div id="hint">Drag & drop a .glb or click Open</div>
    </div>

    <script>
      // Emscripten Module config
      var Module = {
        canvas: (function() { return document.getElementById('glcanvas'); })(),
        locateFile: function(path, prefix) {
          // Keep default; .wasm and .data live next to this file
          return prefix + path;
        }
      };

      // Minimal GLB -> OBJ converter (positions/normals/uvs, triangles only)
      async function glbToObj(arrayBuffer, name) {
        const dv = new DataView(arrayBuffer);
        const MAGIC = 0x46546c67; // 'glTF'
        if (dv.getUint32(0, true) !== MAGIC) throw new Error('Not a GLB');
        const ver = dv.getUint32(4, true);
        if (ver !== 2) throw new Error('GLB version ' + ver + ' not supported');
        const totalLength = dv.getUint32(8, true);
        let off = 12;
        let json = null, bin = null;
        while (off + 8 <= totalLength) {
          const chunkLen = dv.getUint32(off, true); off += 4;
          const chunkType = dv.getUint32(off, true); off += 4;
          const bytes = new Uint8Array(arrayBuffer, off, chunkLen);
          off += chunkLen;
          if (chunkType === 0x4E4F534A) { // JSON
            json = JSON.parse(new TextDecoder('utf-8').decode(bytes));
          } else if (chunkType === 0x004E4942) { // BIN
            bin = bytes;
          }
        }
        if (!json) throw new Error('GLB missing JSON chunk');
        if (!bin) throw new Error('GLB missing BIN chunk');

        const compSize = { 5120:1, 5121:1, 5122:2, 5123:2, 5125:4, 5126:4 };
        const ctors = { 5121: Uint8Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
        const numComps = { SCALAR:1, VEC2:2, VEC3:3, VEC4:4 };

        function readAccessor(ai) {
          const acc = json.accessors[ai];
          if (acc.sparse) throw new Error('sparse accessors not supported');
          const bv = json.bufferViews[acc.bufferView];
          const compT = acc.componentType;
          const ctor = ctors[compT];
          if (!ctor) throw new Error('Unsupported componentType ' + compT);
          const nc = numComps[acc.type];
          if (!nc) throw new Error('Unsupported accessor type ' + acc.type);
          const count = acc.count|0;
          const stride = (bv.byteStride && bv.byteStride !== 0) ? bv.byteStride : compSize[compT] * nc;
          const base = (bv.byteOffset|0) + (acc.byteOffset|0);
          const out = new ctor(count * nc);
          // Handle tight or strided access
          if (stride === compSize[compT] * nc) {
            const view = new ctor(bin.buffer, bin.byteOffset + base, count * nc);
            out.set(view);
            return { data: out, numComps: nc };
          } else {
            for (let i = 0; i < count; i++) {
              const src = new ctor(bin.buffer, bin.byteOffset + base + i*stride, nc);
              for (let c = 0; c < nc; c++) out[i*nc+c] = src[c];
            }
            return { data: out, numComps: nc };
          }
        }

        let obj = '';
        obj += '# Converted from GLB: ' + (name||'model') + '\n';
        let vOffset = 0, vtOffset = 0, vnOffset = 0;

        const meshes = json.meshes || [];
        for (let mi = 0; mi < meshes.length; mi++) {
          const m = meshes[mi];
          const prims = m.primitives || [];
          for (let pi = 0; pi < prims.length; pi++) {
            const p = prims[pi];
            const attrs = p.attributes || {};
            const posA = attrs.POSITION;
            if (posA === undefined) continue; // skip if no positions
            const pos = readAccessor(posA).data; // Float32Array
            const nor = (attrs.NORMAL !== undefined) ? readAccessor(attrs.NORMAL).data : null;
            const uv  = (attrs.TEXCOORD_0 !== undefined) ? readAccessor(attrs.TEXCOORD_0).data : null;
            let idx = null;
            if (p.indices !== undefined) idx = readAccessor(p.indices).data; // Uint16/Uint32
            const vcount = pos.length / 3;

            obj += 'o ' + (m.name || ('Mesh'+mi)) + '_Prim' + pi + '\n';
            for (let i = 0; i < vcount; i++) {
              const x = pos[i*3+0], y = pos[i*3+1], z = pos[i*3+2];
              obj += `v ${x} ${y} ${z}\n`;
            }
            if (uv) {
              for (let i = 0; i < uv.length/2; i++) {
                const u = uv[i*2+0], v = uv[i*2+1];
                obj += `vt ${u} ${v}\n`;
              }
            }
            if (nor) {
              for (let i = 0; i < nor.length/3; i++) {
                const nx = nor[i*3+0], ny = nor[i*3+1], nz = nor[i*3+2];
                obj += `vn ${nx} ${ny} ${nz}\n`;
              }
            }

            // faces
            const faceCount = idx ? (idx.length/3|0) : (vcount/3|0);
            for (let f = 0; f < faceCount; f++) {
              const a = (idx ? idx[f*3+0] : (f*3+0)) + 1;
              const b = (idx ? idx[f*3+1] : (f*3+1)) + 1;
              const c = (idx ? idx[f*3+2] : (f*3+2)) + 1;
              const ia = vOffset + a, ib = vOffset + b, ic = vOffset + c;
              if (uv && nor) {
                obj += `f ${ia}/${vtOffset+a}/${vnOffset+a} ${ib}/${vtOffset+b}/${vnOffset+b} ${ic}/${vtOffset+c}/${vnOffset+c}\n`;
              } else if (uv) {
                obj += `f ${ia}/${vtOffset+a} ${ib}/${vtOffset+b} ${ic}/${vtOffset+c}\n`;
              } else if (nor) {
                obj += `f ${ia}//${vnOffset+a} ${ib}//${vnOffset+b} ${ic}//${vnOffset+c}\n`;
              } else {
                obj += `f ${ia} ${ib} ${ic}\n`;
              }
            }
            vOffset += vcount;
            if (uv) vtOffset += (uv.length/2|0);
            if (nor) vnOffset += (nor.length/3|0);
          }
        }
        return obj;
      }

      function ensureUploadsDir() {
        try { Module.FS_createPath('/', 'uploads', true, true); } catch(e) {}
      }

      function applyLoad(path, name) {
        const op = { op: 'load', path: path, name: name || path.split('/').pop() };
        try { Module.ccall('app_apply_ops_json', 'number', ['string'], [JSON.stringify(op)]); }
        catch (e) { console.error('apply ops failed', e); }
      }

      async function handleFiles(fileList) {
        const f = fileList && fileList[0];
        if (!f) return;
        const lower = f.name.toLowerCase();
        ensureUploadsDir();
        try {
          if (lower.endsWith('.glb')) {
            const buf = await f.arrayBuffer();
            let objText;
            try { objText = await glbToObj(buf, f.name); }
            catch (e) { console.error('GLB parse failed:', e); alert('Failed to parse .glb (no Draco, glTF2 triangles supported)'); return; }
            const u8 = new TextEncoder().encode(objText);
            const dst = '/uploads/' + Date.now() + '_' + f.name.replace(/\.glb$/i, '.obj');
            Module.FS_createDataFile(dst, null, u8, true, true, true);
            applyLoad(dst, f.name.replace(/\.glb$/i, ''));
          } else {
            const buf = await f.arrayBuffer();
            const u8 = new Uint8Array(buf);
            const dst = '/uploads/' + Date.now() + '_' + f.name;
            Module.FS_createDataFile(dst, null, u8, true, true, true);
            applyLoad(dst, f.name.replace(/\.[^.]+$/, ''));
          }
        } catch (e) {
          console.error('File import error:', e);
          alert('Import failed: ' + e.message);
        }
      }

      // UI wiring
      (function(){
        const canvas = document.getElementById('glcanvas');
        const finput = document.getElementById('file-input');
        const drop = document.getElementById('drop');

        finput.addEventListener('change', (e)=>{
          if (e.target.files && e.target.files.length) handleFiles(e.target.files);
          finput.value = '';
        });

        ['dragenter','dragover'].forEach(ev=>{
          canvas.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); drop.style.display='flex'; });
        });
        ['dragleave','drop'].forEach(ev=>{
          canvas.addEventListener(ev, (e)=>{ e.preventDefault(); e.stopPropagation(); drop.style.display='none'; });
        });
        canvas.addEventListener('drop', (e)=>{
          const dt = e.dataTransfer; if (dt && dt.files && dt.files.length) handleFiles(dt.files);
        });
      })();
    </script>
    <script src="objviewer.js"></script>
  </body>
  </html>

